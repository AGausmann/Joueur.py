# Generated by Creer at 02:10AM on September 13, 2015 UTC, git hash: '3f0e08b46657dff30d7c082da7471381f8a1ab62'
# This is where you build your AI for the Checkers game.

from joueur.base_ai import BaseAI

# <<-- Creer-Merge: imports -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
from random import shuffle
# <<-- /Creer-Merge: imports -->>

class AI(BaseAI):
    """ the basic AI functions that are the same between games
    """


    def get_name(self):
        """ this is the name you send to the server to play as.

        Returns
            str: the name you want your player to have
        """
        # <<-- Creer-Merge: get-name -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        return "Checkers Python Player" # REPLACE THIS WITH YOUR TEAM NAME
        # <<-- /Creer-Merge: get-name -->>



    def start(self):
        """ this is called once the game starts and your AI knows its player.id and game. You can initialize your AI here.
        """
        # <<-- Creer-Merge: start -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        self.checkers_map = [[False for y in range(self.game.board_width)] for x in range(self.game.board_height)]
        # <<-- /Creer-Merge: start -->>



    def game_updated(self):
        """ this is called every time the game's state updates, so if you are tracking anything you can update it here.
        """
        # <<-- Creer-Merge: game-updated -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        game = self.game

        for x in range(game.board_width):
            for y in range(game.board_height):
                self.checkers_map[x][y] = None

        self.force_checker = None
        self.cant_move = False
        for checker in game.checkers:
            self.checkers_map[checker.x][checker.y] = checker
            if checker.owner is self.player and checker is game.checker_moved:
                if game.checker_moved_jumped:
                    self.force_checker = checker
                else:
                    self.cant_move = True
        # <<-- /Creer-Merge: game-updated -->>



    def end(self, won, reason):
        """ this is called when the game ends, you can clean up your data and dump files here if need be

        Args:
            won (bool): won == true means you won, won == false means you lost
            reason (str): the reason why you won or lost
        """
        # <<-- Creer-Merge: end -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        # replace with your end logic
        # <<-- /Creer-Merge: end -->>


    def run_turn(self):
        """ This is called every time the AI is asked to respond with a command during their turn

        Returns:
            bool: represents if you want to end your turn. true means end the turn, false means to keep your turn going and re-call runTurn()
        """
        # <<-- Creer-Merge: runTurn -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        checker = True

        while checker:
            checker, tile = self.find_move() or (None, None)

            if checker:
                checker.move(x=tile['x'], y=tile['y'])

        return True # as we are done with our turn
        # <<-- /Creer-Merge: runTurn -->>


    # <<-- Creer-Merge: functions -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
    def find_move(self):
        if self.cant_move:
            return

        checkers = list(self.player.checkers)

        if self.force_checker != None:
            checkers = [ self.force_checker ]

        shuffle(checkers)

        y_direction = self.player.y_direction # we need to know this so unkinged peices don't try to move in illegal directions

        for checker in checkers:
            neighbors = [ # valid move directions for all peices moving in the direction of their player's y (y_direction)
                {'x': checker.x + 1, 'y': checker.y + y_direction, 'requires jump': False},
                {'x': checker.x - 1, 'y': checker.y + y_direction, 'requires jump': False},
            ]

            if checker.kinged: # add the reversed y_direction neighbors to investigate moving to, because kinged peices can move in reverse
                neighbors.extend([
                    {'x': checker.x + 1, 'y': checker.y - y_direction, 'requires jump': False},
                    {'x': checker.x - 1, 'y': checker.y - y_direction, 'requires jump': False},
                ])

            shuffle(neighbors)

            while len(neighbors) > 0: # try to find a valid neighbor to move to
                neighbor = neighbors.pop()
                if neighbor['x'] >= self.game.board_width or neighbor['x'] < 0 or neighbor['y'] >= self.game.board_height or neighbor['y'] < 0:
                    continue # because we can't use this neighbor as it is out of bounds

                if self.force_checker != None: # then we must jump
                    if neighbor['requires jump']:
                        return checker, neighbor
                else:
                    jumping = self.checkers_map[neighbor['x']][neighbor['y']]
                    if jumping == None: # there's no checker there, so it's valid!
                        return checker, neighbor
                    elif jumping.owner != checker.owner: #there is one to jump so let's try to jump it
                        if not neighbor['requires jump']: # then we have not already jumped to get here, so let's try to jump it
                            dx = neighbor['x'] - checker.x
                            dy = neighbor['y'] - checker.y

                            neighbors.append({'x': neighbor['x'] + dx, 'y': neighbor['y'] + dy, 'requires jump': True})
    # <<-- /Creer-Merge: functions -->>
